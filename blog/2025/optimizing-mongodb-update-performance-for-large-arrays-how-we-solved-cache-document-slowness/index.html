<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-9nr6g7ndHdBbuQr5iV6Bg.png"></figure> <h3>Problem Statement</h3> <p>We started noticing a performance degradation when running <strong>update queries</strong> on our MongoDB collection. These updates were targeted at <strong>cache documents</strong> that stored a list of <strong>asset IDs</strong>. Whenever a string underwent moderation, we had to update all associated asset references in the cache doc.</p> <p>Here’s what one such document looks like</p> <pre>{<br>  "_id": "076da3d8d95a4a069574561f85008b90",   <br>  "translated": "इस तरह के अनुरोधों को संसाधित करने में उन्हें आमतौर पर 4-5 दिन लगते हैं।",<br>  "raw": "They usually take 4-5 days to process requests such as these.",<br>  "src": "eng",<br>  "des": "hin",<br>  "configs": [<br>    "test_asset_1",<br>    "test_asset_2",<br>    ...<br>    "test_asset_n"<br>  ],<br>  "success": "Moderated at 25-03-2022"<br>}</pre> <p>Let me break this down:</p> <p>_id: A composite <a href="https://www.md5hashgenerator.com/" rel="external nofollow noopener" target="_blank">MD5 hash</a> created using various doc attributes. It acts as a unique key.<br>raw: The original English string.<br>translated: Its translation.<br>src / des: Source and destination language codes.<br>success: Marks the translation/moderation status.<br>configs: This list can go up to <strong>millions of asset IDs</strong> and represents every asset associated with this translation string.</p> <p>The <strong>update problem</strong>? Updating this massive configs array became extremely <strong>slow</strong> and <strong>unscalable</strong>.</p> <h3>The Underlying Issue: MongoDB + WiredTiger</h3> <p>Digging into MongoDB’s internals (specifically with the WiredTiger storage engine), we found that:</p> <ul> <li>WiredTiger <strong>stores updates in memory</strong> using a linked list per document field.</li> <li>A simple analogy 🌿: <em>Think of it like a grocery list where adding too many items forces the store to rewrite the entire list on a new paper.</em> </li> <li>This update list has a threshold (around 1000 updates) [source: MongoDB JIRA &amp; Engineering Blogs].</li> <li>Beyond this, WiredTiger <strong>rewrites the document to a new memory location</strong>, effectively a copy-on-write.</li> <li>When this happens frequently (as with our ever-growing configs), it leads to <strong>higher memory pressure</strong>, <strong>disk I/O</strong>, and eventually <strong>slower queries</strong>.</li> </ul> <p>This behavior is subtle and not always apparent unless you observe it with MongoDB profiler or system metrics</p> <h3>Our Solution: Inspired by LinkedHashMap</h3> <p>We redesigned the document structure with <strong>fragmentation</strong> in mind. The idea is to <strong>avoid bloated updates</strong> by splitting large configs lists into manageable chunks and introducing a <strong>parent-child structure</strong>.</p> <h4>Before:</h4> <pre>{<br>  "_id": "hash_id",<br>  "configs": [millions of asset IDs]<br>}</pre> <h4>After:</h4> <pre>{<br>  "_id": "parent_hash_id",<br>  "child_refs": ["child_hash_id_1", "child_hash_id_2", ..., "child_hash_id_n"]<br>}<br>{<br>  "_id": "child_hash_id_1",<br>  "configs": [50K asset IDs]<br>}<br>...<br>{<br>  "_id": "child_hash_id_n",<br>  "configs": [30K asset IDs]<br>}</pre> <p>Whenever we need to <strong>moderate a string</strong> (i.e., override the Google-translated version with a more human edit), we only update the relevant <strong>child doc</strong> whose size hasn’t yet breached our limit (50K asset IDs per child).</p> <p><em>We chose 50K after testing different chunk sizes where updates remained fast while minimizing the number of child documents.</em></p> <p>This <strong>drastically improved our update performance</strong>, brought down memory usage, and made our system more maintainable.</p> <h3>TL;DR Learnings</h3> <ul> <li> <strong>Avoid large array updates</strong> in MongoDB if they happen frequently.</li> <li>Understand how <strong>WiredTiger manages memory</strong> for updates — frequent mutations on large documents lead to rewrites and slowness.</li> <li> <strong>Break down large documents</strong> into smaller atomic units using parent-child structures.</li> <li>Use <strong>profiling tools</strong> to identify bottlenecks instead of guessing.</li> <li>Moderation pipelines should be designed with <strong>scalability</strong> in mind from day one.</li> </ul> <h3>References</h3> <ul> <li><a href="https://www.mongodb.com/blog/post/performance-best-practices-wiredtiger" rel="external nofollow noopener" target="_blank">MongoDB: Understanding WiredTiger Update Behavior</a></li> <li>MongoDB Jira on Update Document Rewrite Behavior</li> <li>Engineering Blog: Performance Issues with Large Documents</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=24a16a5c1e2b" width="1" height="1" alt=""></p> </body></html>