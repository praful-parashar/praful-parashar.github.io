<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-9nr6g7ndHdBbuQr5iV6Bg.png"></figure> <h3>Problem Statement</h3> <p>We started noticing a performance degradation when running <strong>update queries</strong> on our MongoDB collection. These updates were targeted at <strong>cache documents</strong> that stored a list of <strong>asset IDs</strong>. Whenever a string underwent moderation, we had to update all associated asset references in the cacheÂ doc.</p> <p>Hereâ€™s what one such document looksÂ like</p> <pre>{<br>  "_id": "076da3d8d95a4a069574561f85008b90",   <br>  "translated": "à¤‡à¤¸ à¤¤à¤°à¤¹ à¤•à¥‡ à¤…à¤¨à¥à¤°à¥‹à¤§à¥‹à¤‚ à¤•à¥‹ à¤¸à¤‚à¤¸à¤¾à¤§à¤¿à¤¤ à¤•à¤°à¤¨à¥‡ à¤®à¥‡à¤‚ à¤‰à¤¨à¥à¤¹à¥‡à¤‚ à¤†à¤®à¤¤à¥Œà¤° à¤ªà¤° 4-5 à¤¦à¤¿à¤¨ à¤²à¤—à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤",<br>  "raw": "They usually take 4-5 days to process requests such as these.",<br>  "src": "eng",<br>  "des": "hin",<br>  "configs": [<br>    "test_asset_1",<br>    "test_asset_2",<br>    ...<br>    "test_asset_n"<br>  ],<br>  "success": "Moderated at 25-03-2022"<br>}</pre> <p>Let me break thisÂ down:</p> <p>_id: A composite <a href="https://www.md5hashgenerator.com/" rel="external nofollow noopener" target="_blank">MD5 hash</a> created using various doc attributes. It acts as a unique key.<br>raw: The original English string.<br>translated: Its translation.<br>src / des: Source and destination language codes.<br>success: Marks the translation/moderation status.<br>configs: This list can go up to <strong>millions of asset IDs</strong> and represents every asset associated with this translation string.</p> <p>The <strong>update problem</strong>? Updating this massive configs array became extremely <strong>slow</strong> and <strong>unscalable</strong>.</p> <h3>The Underlying Issue: MongoDB + WiredTiger</h3> <p>Digging into MongoDBâ€™s internals (specifically with the WiredTiger storage engine), we foundÂ that:</p> <ul> <li>WiredTiger <strong>stores updates in memory</strong> using a linked list per documentÂ field.</li> <li>A simple analogy ğŸŒ¿: <em>Think of it like a grocery list where adding too many items forces the store to rewrite the entire list on a newÂ paper.</em> </li> <li>This update list has a threshold (around 1000 updates) [source: MongoDB JIRA &amp; Engineering Blogs].</li> <li>Beyond this, WiredTiger <strong>rewrites the document to a new memory location</strong>, effectively a copy-on-write.</li> <li>When this happens frequently (as with our ever-growing configs), it leads to <strong>higher memory pressure</strong>, <strong>disk I/O</strong>, and eventually <strong>slowerÂ queries</strong>.</li> </ul> <p>This behavior is subtle and not always apparent unless you observe it with MongoDB profiler or systemÂ metrics</p> <h3>Our Solution: Inspired by LinkedHashMap</h3> <p>We redesigned the document structure with <strong>fragmentation</strong> in mind. The idea is to <strong>avoid bloated updates</strong> by splitting large configs lists into manageable chunks and introducing a <strong>parent-child structure</strong>.</p> <h4>Before:</h4> <pre>{<br>  "_id": "hash_id",<br>  "configs": [millions of asset IDs]<br>}</pre> <h4>After:</h4> <pre>{<br>  "_id": "parent_hash_id",<br>  "child_refs": ["child_hash_id_1", "child_hash_id_2", ..., "child_hash_id_n"]<br>}<br>{<br>  "_id": "child_hash_id_1",<br>  "configs": [50K asset IDs]<br>}<br>...<br>{<br>  "_id": "child_hash_id_n",<br>  "configs": [30K asset IDs]<br>}</pre> <p>Whenever we need to <strong>moderate a string</strong> (i.e., override the Google-translated version with a more human edit), we only update the relevant <strong>child doc</strong> whose size hasnâ€™t yet breached our limit (50K asset IDs perÂ child).</p> <p><em>We chose 50K after testing different chunk sizes where updates remained fast while minimizing the number of child documents.</em></p> <p>This <strong>drastically improved our update performance</strong>, brought down memory usage, and made our system more maintainable.</p> <h3>TL;DR Learnings</h3> <ul> <li> <strong>Avoid large array updates</strong> in MongoDB if they happen frequently.</li> <li>Understand how <strong>WiredTiger manages memory</strong> for updatesâ€Šâ€”â€Šfrequent mutations on large documents lead to rewrites and slowness.</li> <li> <strong>Break down large documents</strong> into smaller atomic units using parent-child structures.</li> <li>Use <strong>profiling tools</strong> to identify bottlenecks instead of guessing.</li> <li>Moderation pipelines should be designed with <strong>scalability</strong> in mind from dayÂ one.</li> </ul> <h3>References</h3> <ul> <li><a href="https://www.mongodb.com/blog/post/performance-best-practices-wiredtiger" rel="external nofollow noopener" target="_blank">MongoDB: Understanding WiredTiger UpdateÂ Behavior</a></li> <li>MongoDB Jira on Update Document RewriteÂ Behavior</li> <li>Engineering Blog: Performance Issues with Large Documents</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=24a16a5c1e2b" width="1" height="1" alt=""></p> </body></html>